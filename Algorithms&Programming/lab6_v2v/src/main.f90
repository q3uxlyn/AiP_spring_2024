! Феллер Г.М., группа 30022
! ЛР №6, вариант 2в

! Вычислить сумму членов рядов, представляющих значения следующих функций
! (суммирование производить до тех пор, пока отношение текущего члена ряда к накопленной сумме не станет меньше заданной величины
! RELERR):
! ln(x + a) = lnx + 2[a/(ax + a) + a^3/3(2x + a)^3 + a^5/5(2x + a)^5 + ...]
! при (2x + a)^2 > a^2

! Указания:
! Проводить вычисления, пока сумма не перестанет меняться. Очередной член (или очередной числитель и знаменатель)
! вычислять относительно предыдущего. Если возможно, то разницу между членами вычислять один раз до цикла (например, x^2).
! В некоторых случаях шаг цикла удобно делать равным 2 (например, если требуются только факториалы чётных чисел).
! Начальные значения переменным давать до цикла. Сравнить результат со встроенной функцией.
! Меняя разновидность вещественного типа на двойную и четверную точность, посмотреть, сколько членов ряда потребуется для сходимости.

! Алгоритм:
! 1. Инициализировать переменные
! 2. Повторять шаги, пока отношение текущего члена ряда к накопленной сумме больше или равно RELERR:
!  2.1 Вычисление n-ого члена ряда
!  2.2 Добавить вычисленное значение к сумме
!  2.3 Увеличить n на 1
! 3. Вернуть сумму

program paragraf6_v2v
   use Environment

   implicit none
   character(*), parameter :: input_file  = "../data/input.txt", &
                              output_file = "output.txt", &
                              fmt         = '(a, T20, "= ", e13.6)'
   integer(I_)             :: In = 0, Out = 0
   real(R_)                :: ln_x_a = 0, x = 0, a = 0
   real, parameter         :: RELERR = 1e-32, PI = acos(-1.0)

   open (file=input_file, newunit=In)
      read (In, *) x, a
   close (In)

   open (file=output_file, encoding=E_, newunit=Out)
      write (Out, fmt) 'x', x
      write (Out, fmt) 'a', a
   close (Out)
   
   open (newunit=Out, file=output_file, position='append')
      write (Out, *)
      ! Выводим результат вычисления встроенной функцией
      write (Out, fmt) 'Fortran ln(x + a)', log(x + a)

      if ( (2 * x + a)**2 <= a ** 2) then
         ! Предупреждение, что условие не выполняется
         write (Out, *)
         write (Out, *) "ln(x + a) не определен для заданных значений"
      else
         ! Вычисление ln(x + a)
         ln_x_a = ln(x, a)
         ! Вывод результатов
         write (Out, *)
         write (Out, fmt) "Error", log(x + a) - ln_x_a
         write (Out, fmt) 'ln(x + a)', ln_x_a
      end if
   close (Out)

contains
   ! Определение функции для вычисления натурального логарифма (x + a)
   ! Вычисление следующего члена ряда:
   ! 1. Умножаем предыдущий член на a**2/(2x+a)**2
   ! 2. Поделить текущий член на k
   ! 3. Увеличить k на 2
   real(R_) pure function ln(x, a) result(new_ln)
      ! Входные параметры x и a
      real(R_), intent(in) :: x, a
      ! Локальные переменные
      real(R_)             :: old_ln, z, diff 
      ! Счетчик цикла
      integer(I_)          :: k

      ! Начальное приближение с использованием формулы
      z = 2 * a / (2 * x + a) ! Первый член ряда
      new_ln = log(x) + z ! Прибавляем ln(x) - по условию задачи
      diff = a ** 2 / (2 * x + a) ** 2 ! Разница между элементами
      k = 3 ! Первый член ряда уже посчитан, начинаем со второго, где  k == 3
      ! Итерации до сходимости
      do while(old_ln /= new_ln)
         ! Сохранение предыдущего значения
         old_ln = new_ln
         ! Вычисление текущего члена ряда
         z = z * diff
         new_ln = new_ln + z / k
         ! Инкремент счетчика
         k = k + 2
      end do
   end function ln

end program paragraf6_v2v
